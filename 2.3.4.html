<!DOCTYPE html>
<html>
			<head>
						<link rel="stylesheet" type="text/css" href="estlos.css">
						<title>2.3.4 M&eacute;todos de direccionamiento</title>
			</head>
					<body>
							<header>
							
								<body style =" background-color: white; color: black; background attachment: fixed 100%; background-size: 100%; background-image: url(imagenes/fondo.jpg); link = # 32CD32; vlink = #32CD32; overflow: visible;" >	
				
								<h2 style ="font-family: courrier; color: white;   text-align: center;">2.3 El ciclo de la instrucci&oacute;n</h2> 

								<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous"/>	
				

									<a href="index.html" class="btn btn-primary">Inicio</a>
									<a href="unidad2.html" class="btn btn-primary">Volver atr&aacute;s</a>
			</header>

									<center><h2>2.3.4 M&eacute;todos de direccionamiento</h2></center>
									<center>
									Son las diferentes maneras de especificar un operando dentro de una instrucci&oacute;n. Un modo de direccionamiento especifica la forma de calcular la direcci&oacute;n de memoria efectiva de un operando mediante el uso de la informaci&oacute;n contenida en registros dentro de una instrucci&oacute;n de la m&aacute;quina.
<br><br>
									<center><h2>Direccionamiento impl&iacute;cito </h2></center>
									Depende solamente de la instrucci&oacute;n, es decir, la instrucci&oacute;n no lleva par&aacute;metros. Particularmente en instrucciones que no accesan memoria, o bien que tienen una forma espec&iacute;fica de accesarla.

									Ejemplos: PUSHF, POPF, NOP
<br><br>

									<center><h2>Modo registro</h2></center>
									Usa solamente registros como operandos. Es el m&aacute;s r&aacute;pido, pues minimiza los recursos necesarios (toda la informaci&oacute;n fluye dentro del EU del CPU)

									Ejemplo: MOV AX, BX

<br><br>
									<center><h2>Modo inmediato</h2></center>
									Tiene dos operandos: un registro y una constante que se usa por su valor. El valor constante no se tiene que buscar en memoria, pues ya se obtuvo al hacer el “fetch” de la instrucci&oacute;n.

									Ejemplo: MOV AH, 9
<br><br>

									<center><h2>Modo directo</h2></center>
									Uno de los operandos involucra una localidad espec&iacute;fica de memoria El valor constante se tiene que buscar en memoria, en la localidad especificada. Es m&aacute;s lento que los anteriores, pero es el m&aacute;s r&aacute;pido para ir a memoria, pues ya “sabe” la localidad, la toma de la instrucci&oacute;n y no la tiene que calcular.

									Ejemplo: MOV AH, [0000] MOV AH, Variableft

									Estas dos instrucciones ser&iacute;an equivalentes, si Variable est&aacute;, por ejemplo, en la localidad 0 de memoria. En la forma primitiva del lenguaje de m&aacute;quina, como el primer ejemplo, se tiene que indicar “mover a AH el contenido (indicado por los corchetes), de la localidad 0 de los datos (lo de los datos es impl&iacute;cito). El lenguaje Ensamblador, sin embargo, nos permite la abstracci&oacute;n del uso de variables, pero como una variable tiene una localidad determinada en memoria, para el procesador funciona igual. La &uacute;nica diferencia consiste en que el programador no tiene que preocuparse por la direcci&oacute;n, ese manejo lo hace autom&aacute;ticamente el Ensamblador.

<br><br>
									<center><h2>Modo indirecto</h2></center>
									Se usan los registros SI, DI como apuntadores.
									<br><br>
									<center><img src="imagenes/tipos1.jpg" height="300" width="400"></center>

									<center>
									<br><br>

				</body>
</html>